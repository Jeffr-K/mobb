# Nestjs/AsyncRequestContext

- async-request-context 를 잘 알아야함.
- 어떤애들을 내보내야 할지에 대해서 고민해봐야함.
- aspect 이용을 고민해봐야함.
- 다른 로깅 통합툴과 어떻게 연동할건지 알아봐야함.




```text
내가 원하는 구조는 

@CommandHandler(PerformHealthCheckCommand)
export class PerformHealthCheckCommandHandler implements ICommandHandler<PerformHealthCheckCommand> {
  private readonly logger = new Logger(PerformHealthCheckCommandHandler.name);

  constructor(private readonly healthService: HealthService) {}

  @WithRequestContext()
  async execute(command: PerformHealthCheckCommand): Promise<string> {
    this.logger.log(`CommandHandler: Executing command`);

    const result = await this.healthService.checkHealth({
      source: 'command',
      type: command.checkType,
      params: command.params
    });

    this.logger.log(`CommandHandler: Command completed.`);
    return result;
  }
}

이렇게 찍으면 자동으로 requestId 가 로그에 찍혀나오도록 구성을 하고 싶은거야. 이렇게 하려면 너가 말한대로 middleware 밖에 답이 없잖아?   @WithRequestContext() 의 현재 역할은 비동기 요청 흐름이 무시되지 않도록 현재 requestId 값을 유지하고 다음에 찍히는 로그를 같은 RequestId 에 포함되도록 구성하는거야.

따라서:

1) 미들웨어를 전역으로 설정가능하게 해야함
2) 미들웨어를 전역으로 설정하지 않으면 해당 데코레이터로 미들웨어처럼 사용해야할 수 있음.
3) 테스트 격리성은 둘째치고 store 에 많은 키가 있으면 이것을 어떻게 효과적으로 관리할지 전략이 필요함
4) 3번의 이슈로 캐싱되어 있는 키를 조회할 API 가 필요할 수도 있음.
5) 여기에 다양한 로거들(winston, ddtrace, sentry) 을 붙이고 작업하도록 구성하고 싶은거야.
```

```text
5. 구조체/키 관리 전략
AsyncRequestContext.store()를 노출해 현재 저장된 키 전체 확인 가능

Nest Interceptor, Guard, Pipe, Service 어디서든 접근 가능

표준 키 네이밍 규칙 (requestId, userId, traceId) 제안

사용자 정의 값도 자유롭게 추가/삭제 가능



 6. 향후 확장 고려
AsyncRequestContextModule.forRoot({ autoInjectLogger: true }) 같은 옵션

@InjectRequestContext() 커스텀 DI 토큰 (원한다면)

GraphQL, WebSocket에서도 context 연결 가능 (Nest lifecycle 제외 대상 처리)

E2E 테스트에서 context mock 기능

```


```text
당신이 만든 모듈이 **nestjs/cls**의 기능을 능가할 수 있도록 확장성과 유연성을 갖추면 훨씬 더 강력하고, 다양한 요구 사항에 맞는 솔루션이 될 것입니다. 다음은 어떻게 **nestjs/cls**를 넘어서는 확장성과 유연성을 갖춘 모듈을 설계할 수 있을지에 대한 몇 가지 주요 전략입니다:

1. 로그와 requestId 추적의 자동화
**nestjs/cls**는 비동기 흐름에서의 데이터 전파에 집중하지만, 로깅 시스템과의 통합에 있어 기본적인 기능만 제공합니다.

당신의 모듈은 requestId와 같은 중요한 정보를 자동으로 로깅에 포함시켜야 합니다. 이를 위해 @WithRequestContext() 데코레이터나 미들웨어를 활용하여 모든 비동기 흐름에서 requestId가 자동으로 관리되고, 로그 시스템(Winston, Datadog, Sentry 등)과 원활하게 통합되도록 합니다.

2. 유연한 컨텍스트 관리
**nestjs/cls**는 특정한 컨텍스트 값을 관리하는 데 강점을 가지지만, **requestId**에 집중된 커스텀 로깅 관리 기능은 추가적인 구현이 필요합니다.

당신의 모듈에서는 다양한 컨텍스트 키(requestId, traceId, userId, tenantId, 등)를 유연하게 관리할 수 있는 기능을 제공하고, 필요한 경우 새로운 컨텍스트 키를 손쉽게 추가할 수 있도록 설계해야 합니다. 이렇게 하면, 확장성 있는 방식으로 다양한 요구 사항에 대응할 수 있습니다.

3. 전역적인 자동 설정
**nestjs/cls**와 비슷하게 전역 설정을 제공하여 애플리케이션의 모든 요청에 대해 자동으로 컨텍스트를 초기화하고 관리할 수 있도록 해야 합니다.

AsyncRequestContextModule.forRoot()와 같은 방식으로 전역 미들웨어나 인터셉터를 설정하여, 수동으로 미들웨어나 데코레이터를 적용하지 않고도 자동으로 요청 ID가 모든 핸들러와 서비스에서 통일되게 유지되도록 할 수 있습니다.

4. API 및 컨텍스트 접근성
**nestjs/cls**에서는 클로저나 클래스를 통해 요청 컨텍스트에 접근하지만, 당신의 모듈은 더 간결하고 직관적인 API를 제공할 수 있습니다. 예를 들어, RequestContext 서비스 같은 형태로 단일 지점에서 쉽게 요청 ID나 다른 컨텍스트 값을 조회하고 관리할 수 있는 기능을 제공하면 좋습니다.

예를 들어, RequestContext.get('requestId')로 requestId를 쉽게 조회할 수 있는 방법을 제공하면 좋겠죠.

5. 테스트 환경에서의 격리성
테스트에서의 격리성을 중요하게 다루는 것은 **nestjs/cls**와 당신의 모듈 모두에서 중요한 고려 사항입니다.

특히, **각 테스트 케이스에서 독립된 requestId**가 보장될 수 있도록, 테스트 환경에서도 컨텍스트를 초기화하고 리셋할 수 있는 기능을 제공하는 것이 중요합니다. 예를 들어, RequestContext.clear() 같은 메서드를 추가하면, 각 테스트가 독립적으로 실행될 수 있도록 돕습니다.

6. 로깅 및 추적 시스템 통합
로깅 시스템(예: Winston)과 추적 시스템(예: Datadog, Sentry)과의 통합을 강화하는 것도 중요한 부분입니다. **requestId**와 같은 컨텍스트 값이 자동으로 로그와 추적에 포함되도록 해야 합니다.

로그와 추적을 위한 기본적인 디폴트 구성을 제공하고, 사용자가 필요에 따라 커스터마이징할 수 있도록 해야 합니다. 예를 들어, WinstonLogger나 DatadogTracer와 쉽게 통합할 수 있도록 미들웨어나 인터셉터로 구성할 수 있습니다.

7. 기존 시스템과의 호환성
기존의 시스템(예: nestjs/cls 또는 다른 컨텍스트 관리 시스템)과의 호환성도 고려할 수 있습니다. 예를 들어, 현재 **nestjs/cls**나 다른 컨텍스트 관리 방식이 사용 중이라면, 새로운 모듈이 기존 시스템을 대체할 수 있도록 매끄럽게 통합될 수 있도록 해야 합니다.

✅ 결론
당신이 설계하려는 모듈은 **nestjs/cls**의 기능을 확장하고, 로깅, 비동기 흐름, 유연한 컨텍스트 관리 등 여러 중요한 요구 사항을 자동화하여, 확장성과 유연성을 제공하는 형태로 발전할 수 있습니다.

이 모듈은 **requestId**와 같은 중요한 정보를 자동으로 관리하고, 애플리케이션 전체에 일관되게 적용하며, 다양한 로깅 및 추적 시스템과 통합하여 효율적이고 안정적인 로깅/추적을 가능하게 할 것입니다.

추가로, 테스트 환경에서의 격리성을 잘 처리하고, 기존 시스템과의 호환성을 고려한다면, 이미 존재하는 라이브러리들을 능가하는 매우 유용한 도구가 될 것입니다.
```







```text
이건 중요하겠네. 기존에 cls 를 이용하면 async storage 를 2개 이용하는 셈이니까

7. 기존 시스템과의 호환성
기존의 시스템(예: nestjs/cls 또는 다른 컨텍스트 관리 시스템)과의 호환성도 고려할 수 있습니다. 예를 들어, 현재 **nestjs/cls**나 다른 컨텍스트 관리 방식이 사용 중이라면, 새로운 모듈이 기존 시스템을 대체할 수 있도록 매끄럽게 통합될 수 있도록 해야 합니다.


ChatGPT said:
네, 맞습니다! 기존 시스템과의 호환성을 고려하는 것은 정말 중요한 부분입니다. 특히, **nestjs/cls**와 같은 기존의 컨텍스트 관리 시스템이 이미 사용되고 있을 때, 새로운 모듈이 이를 대체하거나 통합될 수 있도록 설계해야 합니다. 이 점을 고려하지 않으면, 두 시스템 간의 충돌이나 중복된 상태 관리로 문제가 발생할 수 있기 때문이죠.

기존 시스템과의 호환성 고려 방법
기존 nestjs/cls와의 병행 사용 지원

새로운 모듈을 설계할 때, **기존의 nestjs/cls**나 다른 컨텍스트 관리 시스템을 사용하는 환경에서도 병행해서 사용할 수 있도록 해야 합니다.

예를 들어, **nestjs/cls**를 사용하고 있다면, AsyncRequestContextModule을 다른 이름이나 설정으로 병행하여 사용할 수 있도록 제공할 수 있습니다.

두 시스템 간의 충돌을 방지하려면, 두 시스템이 서로 다른 컨텍스트 영역에서 작동하도록 분리하는 것이 좋습니다. 예를 들어, 기존 cls는 request-context에 대한 기본 흐름을 관리하고, 새로운 모듈은 requestId나 특정 로깅/추적 관련 컨텍스트만 관리하도록 할 수 있습니다.

기존 시스템 대체 및 점진적 전환

**기존 nestjs/cls**를 사용하던 시스템이 있고, 새로운 시스템으로 전환을 원한다면, 점진적인 전환을 지원하는 방법도 있습니다.

예를 들어, 기존 시스템에서 **nestjs/cls**를 점차적으로 새로운 모듈로 대체할 수 있도록, 순차적으로 새로운 시스템을 도입할 수 있는 방법을 마련합니다.

이때, 두 시스템이 같은 컨텍스트 데이터를 공유하도록 설정하면, 이전 시스템을 사용하고 있는 코드에서는 새로운 시스템으로 전환하는 과정에서도 동작에 지장이 없도록 할 수 있습니다.

호환성 있는 API 제공

기존 시스템과의 통합을 용이하게 하려면, 새로운 시스템이 기존 API와 유사하거나 호환 가능한 API를 제공해야 합니다.

예를 들어, **기존의 nestjs/cls**에서 제공하는 getContext(), **setContext()**와 유사한 방식으로 컨텍스트를 조회하거나 설정할 수 있는 API를 제공할 수 있습니다.

또한, 기존 시스템에서 사용하던 데코레이터나 미들웨어 등을 지원하여, 기존 코드가 변경 없이 새로운 모듈로 전환될 수 있도록 할 수 있습니다.

자동 전환 기능

**nestjs/cls**나 다른 컨텍스트 관리 시스템을 사용 중인 환경에서는, 새로운 모듈을 도입할 때 자동 전환 기능을 제공하는 방법도 고려할 수 있습니다.

예를 들어, 새로운 모듈을 초기화할 때, 기존의 nestjs/cls 시스템을 자동으로 비활성화하거나 자동으로 새로운 시스템으로 전환하는 기능을 구현할 수 있습니다. 이렇게 하면 개발자가 별도의 설정 없이도 기존 시스템을 새로운 시스템으로 자연스럽게 마이그레이션할 수 있습니다.

새로운 시스템에서 기존 시스템 지원

기존 시스템을 유지하면서 새로운 시스템의 기능을 추가하는 방식으로, 새로운 모듈이 기존 시스템을 완전히 대체하지 않고, 기존 시스템을 지원하는 역할을 할 수 있습니다.

예를 들어, 기존에 nestjs/cls가 관리하던 **requestId**나 로그 관리의 일부만 새로운 모듈에서 처리하도록 하고, 나머지는 기존 시스템을 유지하면서 두 시스템이 상호 보완적으로 작동하도록 할 수 있습니다.

요약
기존 시스템과의 호환성은 병행 사용과 점진적 전환을 지원하는 방식으로 해결할 수 있습니다. 새로운 모듈을 설계할 때 기존 시스템과의 통합을 고려하여, 두 시스템 간의 충돌을 방지하고, 개발자가 최소한의 변경으로 새로운 시스템을 도입할 수 있도록 해야 합니다.

API 호환성을 제공하고, 자동 전환 기능을 추가하면, 기존 시스템을 사용하는 프로젝트에서도 큰 어려움 없이 새로운 시스템을 적용할 수 있을 것입니다.

기존 시스템을 대체하거나 보완하는 방식으로 유연하게 적용 가능하게 만드는 것이 중요합니다.
```